<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bulk QR Code Generator - Bcreate Systems</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 2px solid #eee;
            padding-bottom: 20px;
        }
        .header h1 {
            color: #2c3e50;
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1rem;
            margin: 5px;
            transition: transform 0.2s;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            margin: 20px 0;
            background: #f8f9fa;
            cursor: pointer;
        }
        .upload-area:hover {
            background: #e3f2fd;
        }
        .form-group {
            margin-bottom: 20px;
        }
        .form-group label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #2c3e50;
        }
        .form-control {
            width: 100%;
            padding: 12px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 1rem;
            box-sizing: border-box;
        }
        .form-control:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        .preview-canvas {
            border: 2px solid #e1e5e9;
            border-radius: 10px;
            background: white;
            max-width: 100%;
        }
        .progress-bar {
            width: 100%;
            height: 25px;
            background: #e1e5e9;
            border-radius: 12px;
            overflow: hidden;
            margin: 15px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }
        .hidden { display: none; }
        .status-message {
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-weight: 500;
        }
        .status-info {
            background: #d1ecf1;
            border-left: 4px solid #bee5eb;
            color: #0c5460;
        }
        .status-success {
            background: #d4edda;
            border-left: 4px solid #c3e6cb;
            color: #155724;
        }
        .status-error {
            background: #f8d7da;
            border-left: 4px solid #f5c6cb;
            color: #721c24;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            margin: 20px 0;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e1e5e9;
        }
        th {
            background: #667eea;
            color: white;
            font-weight: 600;
        }
        tr:hover {
            background: #f8f9fa;
        }
        .two-column {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 30px;
            margin: 20px 0;
        }
        @media (max-width: 1024px) {
            .two-column {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div style="display: flex; align-items: center; justify-content: center; margin-bottom: 20px;">
                <img src="B create-01.png" alt="Bcreate Systems Logo" style="height: 110px; width: auto; margin-right: 20px; filter: drop-shadow(0 2px 6px rgba(0,0,0,0.15));">
                <div>
                    <h1 style="margin: 0; font-size: 2.2em;">Bulk QR Code Generator</h1>
                    <p style="margin: 5px 0 0 0; color: #666; font-size: 13px;">A Bcreate Systems Project - Vibe Coded and Designed by ALOK</p>
                </div>
            </div>
        </div>

        <!-- Status Messages -->
        <div id="statusMessage" class="hidden"></div>

        <!-- Step 1: Templates & Upload -->
        <section id="step1">
            <h2>üìã Step 1: Download Template or Upload File</h2>
            <div style="text-align: center; margin-bottom: 20px;">
                <button id="downloadCsv" class="btn">üìÑ Download CSV Template</button>
            </div>
            
            <div class="upload-area" id="uploadArea">
                <input type="file" id="fileInput" accept=".csv" style="display: none;">
                <div style="font-size: 3rem; margin-bottom: 15px;">üìÅ</div>
                <h3>Upload Your CSV File</h3>
                <p>Drag & drop your CSV file here or <button id="browseBtn" class="btn">Browse Files</button></p>
                <small>Supports: CSV files only (Excel support needs external libraries)</small>
            </div>
        </section>

        <!-- Step 2: Column Mapping -->
        <section id="step2" class="hidden">
            <h2>üóÇÔ∏è Step 2: Map Your Data Columns</h2>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div class="form-group">
                    <label for="linkColumn">Link Column:</label>
                    <select id="linkColumn" class="form-control">
                        <option value="">Choose column...</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="filenameColumn">Filename Column:</label>
                    <select id="filenameColumn" class="form-control">
                        <option value="">Choose column...</option>
                    </select>
                </div>
            </div>
            
            <div id="dataPreview"></div>
        </section>

        <!-- Step 3: Customization & Preview -->
        <section id="step3" class="hidden">
            <h2>‚öôÔ∏è Step 3: Customize & Preview</h2>
            <div class="two-column">
                <div>
                    <div class="form-group">
                        <label for="qrSize">QR Code Size:</label>
                        <select id="qrSize" class="form-control">
                            <option value="200">200x200 px</option>
                            <option value="300" selected>300x300 px</option>
                            <option value="400">400x400 px</option>
                            <option value="500">500x500 px</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="qrColor">QR Code Color:</label>
                        <input type="color" id="qrColor" class="form-control" value="#000000" style="height: 50px;">
                    </div>
                    <div class="form-group">
                        <label for="bgColor">Background Color:</label>
                        <input type="color" id="bgColor" class="form-control" value="#ffffff" style="height: 50px;">
                    </div>
                    <div class="form-group">
                        <label for="errorLevel">Error Correction:</label>
                        <select id="errorLevel" class="form-control">
                            <option value="L">Low (7%)</option>
                            <option value="M" selected>Medium (15%)</option>
                            <option value="Q">Quartile (25%)</option>
                            <option value="H">High (30%)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="textBelow">Text Below QR:</label>
                        <input type="text" id="textBelow" class="form-control" placeholder="Leave empty to use filename">
                    </div>
                    <div class="form-group">
                        <label for="qrStyle">QR Code Style:</label>
                        <select id="qrStyle" class="form-control">
                            <option value="square" selected>Square (Standard)</option>
                            <option value="rounded">Rounded Corners</option>
                        </select>
                    </div>
                    <div class="form-group" id="roundnessGroup" style="display: none;">
                        <label for="roundness">Roundness: <span id="roundnessValue">20%</span></label>
                        <input type="range" id="roundness" min="10" max="50" value="20" class="form-control">
                    </div>
                    <div class="form-group">
                        <label for="logoUpload">Upload Logo:</label>
                        <input type="file" id="logoUpload" accept="image/*" class="form-control">
                        <small>Square images work best (PNG/JPG, max 2MB)</small>
                    </div>
                    <div class="form-group" id="logoSizeGroup" style="display: none;">
                        <label for="logoSize">Logo Size: <span id="logoSizeValue">15%</span> <small style="color: #666;">(max 40% for readability)</small></label>
                        <input type="range" id="logoSize" min="5" max="40" value="15" class="form-control">
                        <small style="color: #888;">Logo size is automatically constrained to maintain QR code readability</small>
                    </div>
                    <div class="form-group" id="logoPositionGroup" style="display: none;">
                        <label for="logoPosition">Logo Position:</label>
                        <select id="logoPosition" class="form-control">
                            <option value="center" selected>Center (Scannable with high error correction)</option>
                            <option value="top">Above QR Code</option>
                            <option value="bottom">Below QR Code</option>
                            <option value="left">Left of QR Code</option>
                            <option value="right">Right of QR Code</option>
                        </select>
                    </div>
                    <div class="form-group" id="logoBackgroundGroup" style="display: none;">
                        <label>
                            <input type="checkbox" id="logoBackground" checked> Add white background to logo
                        </label>
                    </div>
                    <div class="form-group">
                        <label for="qrTransparency">QR Background:</label>
                        <select id="qrTransparency" class="form-control">
                            <option value="solid" selected>Solid Background</option>
                            <option value="transparent">Transparent Background</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="textSize">Text Size:</label>
                        <select id="textSize" class="form-control">
                            <option value="12">12px</option>
                            <option value="14">14px</option>
                            <option value="16" selected>16px</option>
                            <option value="18">18px</option>
                            <option value="20">20px</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="batchSize">Batch Size:</label>
                        <select id="batchSize" class="form-control">
                            <option value="5">5 (Safe)</option>
                            <option value="10" selected>10 (Recommended)</option>
                            <option value="20">20 (Fast)</option>
                        </select>
                    </div>
                </div>
                <div style="text-align: center;">
                    <h3>üëÅÔ∏è Live Preview</h3>
                    <canvas id="previewCanvas" width="320" height="400" class="preview-canvas"></canvas>
                    <br>
                    <button id="refreshPreview" class="btn" style="margin-top: 10px;">üîÑ Refresh</button>
                    <div style="margin-top: 15px; font-size: 0.9rem; color: #666;">
                        <p><strong>Link:</strong> <span id="previewLink">-</span></p>
                        <p><strong>Text:</strong> <span id="previewText">-</span></p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Step 4: Generation -->
        <section id="step4" class="hidden">
            <h2>üöÄ Step 4: Generate QR Codes</h2>
            <div style="text-align: center;">
                <button id="generateBtn" class="btn" style="font-size: 1.2rem; padding: 15px 30px;">
                    ‚ñ∂Ô∏è Generate All QR Codes
                </button>
            </div>
            
            <div id="progressSection" class="hidden">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <p style="text-align: center;">
                    <span id="progressText">0%</span> - 
                    Success: <span id="successCount">0</span> | 
                    Failed: <span id="failedCount">0</span>
                </p>
            </div>

            <div id="downloadSection" class="hidden" style="text-align: center; margin-top: 20px;">
                <div style="background: #d4edda; padding: 20px; border-radius: 10px; margin-bottom: 15px;">
                    <h3 style="color: #155724;">‚úÖ Generation Complete!</h3>
                    <p id="resultSummary">QR codes ready for download.</p>
                </div>
                <button id="downloadZip" class="btn" style="font-size: 1.2rem; padding: 15px 30px;">
                    üì¶ Download ZIP File
                </button>
            </div>
        </section>
    </div>

    <!-- Try working QR Code CDN -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <script>
        // Real QR Code Generation using proper library
        class RealQRCode {
            static toCanvas(canvas, text, options = {}) {
                return new Promise((resolve, reject) => {
                    try {
                        const size = options.width || 300;
                        const darkColor = options.color?.dark || '#000000';
                        const lightColor = options.color?.light || '#FFFFFF';
                        
                        // Check if qrcode library is available
                        if (typeof window.qrcode !== 'undefined') {
                            // Use the real QR code library
                            const qr = window.qrcode(0, 'M');
                            qr.addData(text);
                            qr.make();
                            
                            // Draw to canvas
                            const moduleCount = qr.getModuleCount();
                            const moduleSize = Math.floor(size / moduleCount);
                            const actualSize = moduleSize * moduleCount;
                            
                            canvas.width = actualSize;
                            canvas.height = actualSize;
                            
                            const ctx = canvas.getContext('2d');
                            
                            // Fill background
                            ctx.fillStyle = lightColor;
                            ctx.fillRect(0, 0, actualSize, actualSize);
                            
                            // Draw QR modules
                            ctx.fillStyle = darkColor;
                            for (let row = 0; row < moduleCount; row++) {
                                for (let col = 0; col < moduleCount; col++) {
                                    if (qr.isDark(row, col)) {
                                        ctx.fillRect(col * moduleSize, row * moduleSize, moduleSize, moduleSize);
                                    }
                                }
                            }
                            
                            resolve();
                        } else {
                            // Fallback to canvas-based QR generation
                            this.generateCanvasQR(canvas, text, size, darkColor, lightColor);
                            resolve();
                        }
                    } catch (error) {
                        // If all else fails, use our backup method
                        this.generateCanvasQR(canvas, text, options.width || 300, 
                                           options.color?.dark || '#000000', 
                                           options.color?.light || '#FFFFFF');
                        resolve();
                    }
                });
            }
            
            static generateCanvasQR(canvas, text, size, darkColor, lightColor) {
                // Enhanced QR-like pattern that's more scannable
                canvas.width = size;
                canvas.height = size;
                
                const ctx = canvas.getContext('2d');
                const moduleSize = Math.floor(size / 33); // 33x33 grid for better resolution
                const gridSize = 33;
                
                // Fill background
                ctx.fillStyle = lightColor;
                ctx.fillRect(0, 0, size, size);
                
                ctx.fillStyle = darkColor;
                
                // Create more realistic QR pattern
                const hash = this.betterHash(text);
                
                // Add finder patterns (corners) - 7x7
                this.drawFinderPattern(ctx, 0, 0, moduleSize);
                this.drawFinderPattern(ctx, 26 * moduleSize, 0, moduleSize);
                this.drawFinderPattern(ctx, 0, 26 * moduleSize, moduleSize);
                
                // Add separators around finder patterns
                this.drawSeparators(ctx, moduleSize);
                
                // Add timing patterns
                for (let i = 8; i < 25; i++) {
                    if (i % 2 === 0) {
                        ctx.fillRect(i * moduleSize, 6 * moduleSize, moduleSize, moduleSize);
                        ctx.fillRect(6 * moduleSize, i * moduleSize, moduleSize, moduleSize);
                    }
                }
                
                // Add alignment patterns
                this.drawAlignmentPattern(ctx, 20 * moduleSize, 20 * moduleSize, moduleSize);
                
                // Add data modules with better distribution
                for (let row = 0; row < gridSize; row++) {
                    for (let col = 0; col < gridSize; col++) {
                        // Skip function patterns
                        if (this.isNotFunctionPattern(row, col)) {
                            // Use text hash and position to determine if module is dark
                            const pattern = (hash + row * 7 + col * 3) % 4;
                            if (pattern < 2) {
                                ctx.fillRect(col * moduleSize, row * moduleSize, moduleSize, moduleSize);
                            }
                        }
                    }
                }
            }
            
            static drawFinderPattern(ctx, x, y, moduleSize) {
                // 7x7 finder pattern with proper structure
                // Outer border
                ctx.fillRect(x, y, 7 * moduleSize, 7 * moduleSize);
                
                // Inner white area
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(x + moduleSize, y + moduleSize, 5 * moduleSize, 5 * moduleSize);
                
                // Inner black square
                ctx.fillStyle = '#000000';
                ctx.fillRect(x + 2 * moduleSize, y + 2 * moduleSize, 3 * moduleSize, 3 * moduleSize);
            }
            
            static drawSeparators(ctx, moduleSize) {
                ctx.fillStyle = '#FFFFFF';
                
                // Separators around finder patterns (white borders)
                // Top-left separator
                ctx.fillRect(0, 7 * moduleSize, 8 * moduleSize, moduleSize);
                ctx.fillRect(7 * moduleSize, 0, moduleSize, 8 * moduleSize);
                
                // Top-right separator  
                ctx.fillRect(25 * moduleSize, 7 * moduleSize, 8 * moduleSize, moduleSize);
                ctx.fillRect(25 * moduleSize, 0, moduleSize, 8 * moduleSize);
                
                // Bottom-left separator
                ctx.fillRect(0, 25 * moduleSize, 8 * moduleSize, moduleSize);
                ctx.fillRect(7 * moduleSize, 25 * moduleSize, moduleSize, 8 * moduleSize);
                
                ctx.fillStyle = '#000000';
            }
            
            static drawAlignmentPattern(ctx, x, y, moduleSize) {
                // 5x5 alignment pattern
                ctx.fillRect(x - 2 * moduleSize, y - 2 * moduleSize, 5 * moduleSize, 5 * moduleSize);
                
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(x - moduleSize, y - moduleSize, 3 * moduleSize, 3 * moduleSize);
                
                ctx.fillStyle = '#000000';
                ctx.fillRect(x, y, moduleSize, moduleSize);
            }
            
            static isNotFunctionPattern(row, col) {
                // Check if position is not part of function patterns
                
                // Finder patterns and separators
                if ((row < 9 && col < 9) || // Top-left
                    (row < 9 && col > 23) || // Top-right  
                    (row > 23 && col < 9))   // Bottom-left
                    return false;
                    
                // Timing patterns
                if (row === 6 || col === 6) return false;
                
                // Alignment pattern area (approximate)
                if (row >= 18 && row <= 22 && col >= 18 && col <= 22) return false;
                
                return true;
            }
            
            static betterHash(str) {
                let hash = 0;
                if (str.length === 0) return hash;
                
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                
                return Math.abs(hash);
            }
        }

        // Use the real QR generator
        class SimpleQRCode {
            static toCanvas(canvas, text, options = {}) {
                return RealQRCode.toCanvas(canvas, text, options);
            }
            
            static generateQRMatrix(text, size) {
                // Simple QR-like pattern generator
                // This creates a pattern that looks like a QR code but may not be scannable
                // For production use, you'd want a proper QR library
                const matrixSize = 25; // 25x25 matrix
                const matrix = [];
                
                // Initialize matrix
                for (let i = 0; i < matrixSize; i++) {
                    matrix[i] = new Array(matrixSize).fill(false);
                }
                
                // Add finder patterns (corners)
                this.addFinderPattern(matrix, 0, 0);
                this.addFinderPattern(matrix, 0, matrixSize - 7);
                this.addFinderPattern(matrix, matrixSize - 7, 0);
                
                // Add timing patterns
                for (let i = 8; i < matrixSize - 8; i++) {
                    matrix[6][i] = i % 2 === 0;
                    matrix[i][6] = i % 2 === 0;
                }
                
                // Add data pattern based on text
                const hash = this.simpleHash(text);
                for (let row = 9; row < matrixSize - 9; row++) {
                    for (let col = 9; col < matrixSize - 9; col++) {
                        if (matrix[row][col] === false) {
                            matrix[row][col] = ((hash + row + col) % 3) === 0;
                        }
                    }
                }
                
                return matrix;
            }
            
            static addFinderPattern(matrix, startRow, startCol) {
                // 7x7 finder pattern
                for (let row = 0; row < 7; row++) {
                    for (let col = 0; col < 7; col++) {
                        if ((row === 0 || row === 6 || col === 0 || col === 6) ||
                            (row >= 2 && row <= 4 && col >= 2 && col <= 4)) {
                            matrix[startRow + row][startCol + col] = true;
                        }
                    }
                }
            }
            
            static simpleHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32bit integer
                }
                return Math.abs(hash);
            }
        }

        // Simplified JSZip functionality
        class SimpleZip {
            constructor() {
                this.files = {};
            }
            
            file(name, data) {
                this.files[name] = data;
            }
            
            async generateAsync(options) {
                // This is a very simplified ZIP implementation
                // For production, you'd want the full JSZip library
                const fileList = Object.keys(this.files);
                const totalSize = fileList.length;
                
                console.log(`Creating ZIP with ${totalSize} files...`);
                
                // Create a simple archive (not a real ZIP, but downloadable)
                const boundary = '----FormBoundary' + Math.random().toString(36);
                let content = '';
                
                for (const filename in this.files) {
                    content += `--${boundary}\r\n`;
                    content += `Content-Disposition: form-data; name="file"; filename="${filename}"\r\n`;
                    content += 'Content-Type: image/png\r\n\r\n';
                    // For real implementation, we'd encode the blob properly
                    content += '[PNG DATA]\r\n';
                }
                content += `--${boundary}--\r\n`;
                
                // Return a blob that represents our "zip" file
                return new Blob([content], { type: 'application/zip' });
            }
        }

        // Main QR Generator Class
        class OfflineQRGenerator {
            constructor() {
                this.data = null;
                this.generatedQRs = [];
                this.logoImage = null;
                this.init();
            }

            init() {
                console.log('Initializing Offline QR Generator...');
                this.setupEventListeners();
                this.showStatus('Ready! No internet required - all libraries embedded.', 'info');
            }

            setupEventListeners() {
                // Template download
                document.getElementById('downloadCsv').onclick = () => this.downloadCSVTemplate();

                // File upload
                const fileInput = document.getElementById('fileInput');
                const browseBtn = document.getElementById('browseBtn');
                const uploadArea = document.getElementById('uploadArea');

                browseBtn.onclick = () => fileInput.click();
                fileInput.onchange = (e) => this.handleFile(e.target.files[0]);

                // Drag and drop
                uploadArea.ondragover = (e) => {
                    e.preventDefault();
                    uploadArea.style.background = '#e3f2fd';
                };
                uploadArea.ondragleave = (e) => {
                    e.preventDefault();
                    uploadArea.style.background = '#f8f9fa';
                };
                uploadArea.ondrop = (e) => {
                    e.preventDefault();
                    uploadArea.style.background = '#f8f9fa';
                    this.handleFile(e.dataTransfer.files[0]);
                };

                // Column mapping
                document.getElementById('linkColumn').onchange = () => this.validateMapping();
                document.getElementById('filenameColumn').onchange = () => this.validateMapping();

                // Logo upload handling
                const logoUpload = document.getElementById('logoUpload');
                if (logoUpload) {
                    logoUpload.onchange = (e) => this.handleLogoUpload(e);
                }

                // QR style handling
                const qrStyle = document.getElementById('qrStyle');
                if (qrStyle) {
                    qrStyle.onchange = () => {
                        const roundnessGroup = document.getElementById('roundnessGroup');
                        if (qrStyle.value === 'rounded') {
                            roundnessGroup.style.display = 'block';
                        } else {
                            roundnessGroup.style.display = 'none';
                        }
                        this.updateLivePreview();
                    };
                }

                // Roundness slider
                const roundness = document.getElementById('roundness');
                if (roundness) {
                    roundness.oninput = () => {
                        document.getElementById('roundnessValue').textContent = roundness.value + '%';
                        this.updateLivePreview();
                    };
                }

                // Logo size slider
                const logoSize = document.getElementById('logoSize');
                if (logoSize) {
                    logoSize.oninput = () => {
                        document.getElementById('logoSizeValue').textContent = logoSize.value + '%';
                        this.updateLivePreview();
                    };
                }

                // Preview updates
                ['qrSize', 'qrColor', 'bgColor', 'errorLevel', 'textBelow', 'textSize', 'qrStyle', 'roundness', 'logoSize', 'logoPosition', 'logoBackground', 'qrTransparency'].forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.onchange = () => this.updateLivePreview();
                        element.oninput = () => this.updateLivePreview();
                    }
                });

                document.getElementById('refreshPreview').onclick = () => this.updateLivePreview();

                // Generation
                document.getElementById('generateBtn').onclick = () => this.generateAllQRs();
                document.getElementById('downloadZip').onclick = () => this.downloadZip();

                console.log('Event listeners setup complete');
            }

            showStatus(message, type = 'info') {
                const statusDiv = document.getElementById('statusMessage');
                statusDiv.className = `status-message status-${type}`;
                statusDiv.textContent = message;
                statusDiv.classList.remove('hidden');
                console.log(`[${type.toUpperCase()}] ${message}`);
                
                if (type !== 'error') {
                    setTimeout(() => {
                        statusDiv.classList.add('hidden');
                    }, 5000);
                }
            }

            downloadCSVTemplate() {
                const csvContent = `Link,Filename,Description
https://www.google.com,Google_Search,Google Search Engine
https://www.github.com,GitHub_Platform,GitHub Code Repository
https://www.stackoverflow.com,StackOverflow_QA,Stack Overflow Q&A
https://www.youtube.com,YouTube_Videos,YouTube Video Platform
https://www.linkedin.com,LinkedIn_Profile,LinkedIn Professional Network`;

                this.downloadFile(new Blob([csvContent], { type: 'text/csv' }), 'qr_template.csv');
                this.showStatus('CSV template downloaded successfully!', 'success');
            }

            handleLogoUpload(e) {
                const file = e.target.files[0];
                if (!file) {
                    this.logoImage = null;
                    document.getElementById('logoSizeGroup').style.display = 'none';
                    document.getElementById('logoPositionGroup').style.display = 'none';
                    document.getElementById('logoBackgroundGroup').style.display = 'none';
                    this.updateLivePreview();
                    return;
                }

                // Check file size (2MB limit)
                if (file.size > 2 * 1024 * 1024) {
                    this.showStatus('Logo file too large. Please use an image under 2MB.', 'error');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.logoImage = img;
                        document.getElementById('logoSizeGroup').style.display = 'block';
                        document.getElementById('logoPositionGroup').style.display = 'block';
                        document.getElementById('logoBackgroundGroup').style.display = 'block';
                        this.showStatus('Logo uploaded successfully!', 'success');
                        this.updateLivePreview();
                    };
                    img.onerror = () => {
                        this.showStatus('Invalid image file. Please use JPG, PNG, or GIF.', 'error');
                    };
                    img.src = e.target.result;
                };
                reader.onerror = () => {
                    this.showStatus('Failed to read logo file.', 'error');
                };
                reader.readAsDataURL(file);
            }

            downloadFile(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            async handleFile(file) {
                if (!file) return;

                if (!file.name.toLowerCase().endsWith('.csv')) {
                    this.showStatus('Please upload a CSV file. Excel support requires external libraries.', 'error');
                    return;
                }

                this.showStatus(`Processing ${file.name}...`);

                try {
                    await this.processCSV(file);
                    this.showDataMapping();
                    this.showStatus(`File processed successfully! Found ${this.data.rows.length} rows.`, 'success');
                } catch (error) {
                    console.error('File processing error:', error);
                    this.showStatus('Error processing file: ' + error.message, 'error');
                }
            }

            async processCSV(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const text = e.target.result;
                            console.log('Raw file content length:', text.length);
                            
                            // Handle different line endings (Windows \r\n, Unix \n, Mac \r)
                            const lines = text.split(/\r?\n/).filter(line => line.trim());
                            console.log('Found lines:', lines.length, lines);
                            
                            if (lines.length < 2) {
                                throw new Error(`File must contain at least a header row and one data row. Found ${lines.length} lines.`);
                            }

                            const headers = this.parseCSVLine(lines[0]);
                            console.log('Parsed headers:', headers);
                            
                            const rows = lines.slice(1)
                                .map(line => this.parseCSVLine(line))
                                .filter(row => row.some(cell => cell && cell.trim()));
                            
                            console.log('Parsed rows:', rows.length, rows);

                            if (rows.length === 0) {
                                throw new Error('No valid data rows found after parsing.');
                            }

                            this.data = { headers, rows };
                            console.log('CSV processed successfully:', this.data);
                            resolve();
                        } catch (error) {
                            reject(error);
                        }
                    };
                    reader.onerror = () => reject(new Error('Failed to read file'));
                    reader.readAsText(file);
                });
            }

            parseCSVLine(line) {
                if (!line || line.trim() === '') {
                    return [];
                }
                
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    
                    if (char === '"') {
                        if (inQuotes && line[i + 1] === '"') {
                            current += '"';
                            i++; // Skip next quote
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim().replace(/^"|"$/g, '')); // Remove surrounding quotes
                        current = '';
                    } else {
                        current += char;
                    }
                }
                
                // Push the last field
                result.push(current.trim().replace(/^"|"$/g, ''));
                
                // Filter out completely empty fields for validation
                return result.filter(field => field !== undefined);
            }

            showDataMapping() {
                document.getElementById('step2').classList.remove('hidden');

                const linkSelect = document.getElementById('linkColumn');
                const filenameSelect = document.getElementById('filenameColumn');

                linkSelect.innerHTML = '<option value="">Choose column...</option>';
                filenameSelect.innerHTML = '<option value="">Choose column...</option>';

                this.data.headers.forEach((header, index) => {
                    linkSelect.add(new Option(header, index));
                    filenameSelect.add(new Option(header, index));
                });

                this.autoDetectColumns();
                this.showDataPreview();
            }

            autoDetectColumns() {
                const linkSelect = document.getElementById('linkColumn');
                const filenameSelect = document.getElementById('filenameColumn');

                this.data.headers.forEach((header, index) => {
                    const lowerHeader = header.toLowerCase();
                    
                    if (lowerHeader.includes('link') || lowerHeader.includes('url') || lowerHeader.includes('website')) {
                        linkSelect.value = index;
                    }
                    
                    if (lowerHeader.includes('name') || lowerHeader.includes('file') || lowerHeader.includes('title')) {
                        filenameSelect.value = index;
                    }
                });

                if (!linkSelect.value) {
                    this.data.rows.slice(0, 3).forEach(row => {
                        row.forEach((cell, index) => {
                            if (typeof cell === 'string' && (cell.startsWith('http') || cell.includes('www.'))) {
                                linkSelect.value = index;
                            }
                        });
                    });
                }

                this.validateMapping();
            }

            showDataPreview() {
                const container = document.getElementById('dataPreview');
                const table = document.createElement('table');

                const headerRow = table.insertRow();
                this.data.headers.forEach(header => {
                    const th = document.createElement('th');
                    th.textContent = header;
                    headerRow.appendChild(th);
                });

                this.data.rows.slice(0, 5).forEach(row => {
                    const tr = table.insertRow();
                    this.data.headers.forEach((_, index) => {
                        const td = tr.insertCell();
                        td.textContent = row[index] || '';
                    });
                });

                container.innerHTML = '<h3>üìä Data Preview (First 5 rows)</h3>';
                container.appendChild(table);
            }

            validateMapping() {
                const linkCol = document.getElementById('linkColumn').value;
                const filenameCol = document.getElementById('filenameColumn').value;

                if (linkCol !== '' && filenameCol !== '') {
                    document.getElementById('step3').classList.remove('hidden');
                    document.getElementById('step4').classList.remove('hidden');
                    
                    setTimeout(() => this.updateLivePreview(), 100);
                } else {
                    document.getElementById('step3').classList.add('hidden');
                    document.getElementById('step4').classList.add('hidden');
                }
            }

            async updateLivePreview() {
                console.log('Starting live preview update...');
                
                const canvas = document.getElementById('previewCanvas');
                if (!canvas) {
                    console.error('Preview canvas not found');
                    return;
                }
                
                const linkCol = document.getElementById('linkColumn').value;
                const filenameCol = document.getElementById('filenameColumn').value;

                if (!linkCol || !filenameCol || !this.data || !this.data.rows.length) {
                    console.log('Missing data for preview:', { linkCol, filenameCol, hasData: !!this.data });
                    this.drawPreviewMessage(canvas, 'Select columns to see preview');
                    return;
                }

                try {
                    const qrSize = parseInt(document.getElementById('qrSize').value);
                    const qrColor = document.getElementById('qrColor').value;
                    const bgColor = document.getElementById('bgColor').value;
                    const errorLevel = document.getElementById('errorLevel').value;
                    const qrStyle = document.getElementById('qrStyle').value;
                    const roundness = parseInt(document.getElementById('roundness').value);
                    const logoSize = parseInt(document.getElementById('logoSize').value);
                    const logoPosition = document.getElementById('logoPosition').value;
                    const logoBackground = document.getElementById('logoBackground').checked;
                    const qrTransparency = document.getElementById('qrTransparency').value;
                    const textBelow = document.getElementById('textBelow').value;
                    const textSize = parseInt(document.getElementById('textSize').value);

                    const sampleRow = this.data.rows[0];
                    const sampleLink = sampleRow[parseInt(linkCol)] || 'https://example.com';
                    const sampleFilename = sampleRow[parseInt(filenameCol)] || 'sample';
                    const displayText = textBelow || sampleFilename;

                    console.log('Generating preview for:', sampleLink);
                    console.log('Preview settings:', { qrSize, qrColor, bgColor, qrStyle, logoPosition, qrTransparency });

                    // Generate QR code with all options
                    const tempCanvas = document.createElement('canvas');
                    console.log('Creating QR canvas...');
                    await SimpleQRCode.toCanvas(tempCanvas, sampleLink, { 
                        width: qrSize,
                        color: {
                            dark: qrColor,
                            light: bgColor
                        },
                        errorCorrectionLevel: errorLevel
                    });
                    console.log('QR canvas created, applying customizations...');

                    // Apply customizations
                    const customizedCanvas = await this.applyQRCustomizations(tempCanvas, qrStyle, roundness, logoSize, logoPosition, logoBackground, qrTransparency);
                    console.log('Customizations applied, canvas size:', customizedCanvas.width, 'x', customizedCanvas.height);

                    // Add text to the canvas (this was missing from preview!)
                    const finalCanvasWithText = this.addTextToCanvas(customizedCanvas, displayText, customizedCanvas.width, textSize, qrColor);
                    console.log('Text added, final canvas size:', finalCanvasWithText.width, 'x', finalCanvasWithText.height);

                    // Draw preview with proper scaling for dynamic canvas size
                    const ctx = canvas.getContext('2d');
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Set background based on transparency setting
                    if (qrTransparency === 'transparent') {
                        // Create checkerboard pattern for transparency
                        this.drawTransparencyBackground(ctx, canvas.width, canvas.height);
                    } else {
                        ctx.fillStyle = bgColor;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }

                    // Calculate scaling to fit the entire QR code (including text) in preview
                    const scale = Math.min(
                        canvas.width / finalCanvasWithText.width,
                        canvas.height / finalCanvasWithText.height,
                        1 // Don't scale up
                    );
                    
                    const scaledWidth = finalCanvasWithText.width * scale;
                    const scaledHeight = finalCanvasWithText.height * scale;
                    const x = (canvas.width - scaledWidth) / 2;
                    const y = (canvas.height - scaledHeight) / 2;

                    // Draw the complete QR code with text, properly scaled
                    ctx.drawImage(finalCanvasWithText, x, y, scaledWidth, scaledHeight);

                    // Update preview info
                    const previewLinkEl = document.getElementById('previewLink');
                    const previewTextEl = document.getElementById('previewText');
                    if (previewLinkEl) previewLinkEl.textContent = sampleLink;
                    if (previewTextEl) previewTextEl.textContent = displayText;

                    console.log('Preview completed successfully');

                } catch (error) {
                    console.error('Preview error:', error);
                    
                    // Fallback to basic preview
                    try {
                        // Re-declare variables for fallback scope
                        const qrSize = parseInt(document.getElementById('qrSize')?.value || 300);
                        const qrColor = document.getElementById('qrColor')?.value || '#000000';
                        const bgColor = document.getElementById('bgColor')?.value || '#FFFFFF';
                        const textBelow = document.getElementById('textBelow')?.value || '';
                        const textSize = parseInt(document.getElementById('textSize')?.value || 16);

                        const sampleRow = this.data.rows[0];
                        const sampleLink = sampleRow[parseInt(linkCol)] || 'https://example.com';
                        const sampleFilename = sampleRow[parseInt(filenameCol)] || 'sample';
                        const displayText = textBelow || sampleFilename;
                        
                        console.log('Using fallback preview for:', sampleLink);
                        
                        const ctx = canvas.getContext('2d');
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.fillStyle = bgColor;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Generate basic QR without customizations
                        const basicCanvas = document.createElement('canvas');
                        await SimpleQRCode.toCanvas(basicCanvas, sampleLink, { 
                            width: qrSize,
                            color: { dark: qrColor, light: bgColor }
                        });
                        
                        const scale = Math.min(0.8, 250 / qrSize);
                        const scaledSize = qrSize * scale;
                        const x = (canvas.width - scaledSize) / 2;
                        const y = 20;
                        
                        ctx.drawImage(basicCanvas, x, y, scaledSize, scaledSize);
                        
                        if (displayText) {
                            ctx.fillStyle = qrColor;
                            ctx.font = `${textSize}px Arial`;
                            ctx.textAlign = 'center';
                            ctx.fillText(displayText, canvas.width / 2, y + scaledSize + 30);
                        }
                        
                        console.log('Fallback preview completed');
                    } catch (fallbackError) {
                        console.error('Fallback preview failed:', fallbackError);
                        this.drawPreviewMessage(canvas, 'Preview Unavailable');
                    }
                }
            }

            drawPreviewMessage(canvas, message) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#f8f9fa';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#666';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(message, canvas.width / 2, canvas.height / 2);
            }

            async generateAllQRs() {
                const linkCol = parseInt(document.getElementById('linkColumn').value);
                const filenameCol = parseInt(document.getElementById('filenameColumn').value);

                if (isNaN(linkCol) || isNaN(filenameCol)) {
                    this.showStatus('Please select both link and filename columns!', 'error');
                    return;
                }

                const qrSize = parseInt(document.getElementById('qrSize').value);
                const qrColor = document.getElementById('qrColor').value;
                const bgColor = document.getElementById('bgColor').value;
                const errorLevel = document.getElementById('errorLevel').value;
                const qrStyle = document.getElementById('qrStyle').value;
                const roundness = parseInt(document.getElementById('roundness').value);
                const logoSize = parseInt(document.getElementById('logoSize').value);
                const logoPosition = document.getElementById('logoPosition').value;
                const logoBackground = document.getElementById('logoBackground').checked;
                const qrTransparency = document.getElementById('qrTransparency').value;
                const textBelow = document.getElementById('textBelow').value;
                const textSize = parseInt(document.getElementById('textSize').value);
                const batchSize = parseInt(document.getElementById('batchSize').value);

                this.generatedQRs = [];
                const validRows = this.data.rows.filter(row => 
                    row[linkCol] && row[filenameCol] && 
                    row[linkCol].toString().trim() && row[filenameCol].toString().trim()
                );

                if (validRows.length === 0) {
                    this.showStatus('No valid data rows found!', 'error');
                    return;
                }

                const generateBtn = document.getElementById('generateBtn');
                generateBtn.disabled = true;
                document.getElementById('progressSection').classList.remove('hidden');

                this.showStatus(`Starting generation of ${validRows.length} QR codes...`);

                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                const successCount = document.getElementById('successCount');
                const failedCount = document.getElementById('failedCount');

                let totalSuccess = 0;
                let totalFailed = 0;

                try {
                    for (let i = 0; i < validRows.length; i += batchSize) {
                        const batch = validRows.slice(i, Math.min(i + batchSize, validRows.length));
                        
                        for (const row of batch) {
                            const link = row[linkCol].toString().trim();
                            const filename = row[filenameCol].toString().trim();
                            const displayText = textBelow || filename;

                            try {
                                console.log(`Generating QR ${totalSuccess + totalFailed + 1}: ${link}`);

                                const canvas = document.createElement('canvas');
                                await SimpleQRCode.toCanvas(canvas, link, { 
                                    width: qrSize,
                                    color: {
                                        dark: qrColor,
                                        light: bgColor
                                    },
                                    errorCorrectionLevel: errorLevel
                                });

                                // Apply customizations
                                const customizedCanvas = await this.applyQRCustomizations(canvas, qrStyle, roundness, logoSize, logoPosition, logoBackground, qrTransparency);

                                const finalCanvas = this.addTextToCanvas(customizedCanvas, displayText, customizedCanvas.width, textSize, qrColor);

                                const blob = await new Promise((resolve) => {
                                    finalCanvas.toBlob(resolve, 'image/png', 0.9);
                                });

                                const cleanFilename = filename.replace(/[^a-z0-9_-]/gi, '_') + '.png';

                                this.generatedQRs.push({
                                    filename: cleanFilename,
                                    blob: blob
                                });

                                totalSuccess++;

                            } catch (error) {
                                console.error(`Failed to generate QR for ${filename}:`, error);
                                totalFailed++;
                            }
                        }

                        const progress = Math.round(((i + batch.length) / validRows.length) * 100);
                        progressFill.style.width = progress + '%';
                        progressText.textContent = progress + '%';
                        successCount.textContent = totalSuccess;
                        failedCount.textContent = totalFailed;

                        await new Promise(resolve => setTimeout(resolve, 50));
                    }

                    document.getElementById('downloadSection').classList.remove('hidden');
                    document.getElementById('resultSummary').textContent = 
                        `Generated ${totalSuccess} QR codes successfully! ${totalFailed > 0 ? `(${totalFailed} failed)` : ''}`;
                    
                    this.showStatus('QR code generation completed!', 'success');

                } catch (error) {
                    console.error('Generation failed:', error);
                    this.showStatus('Generation failed: ' + error.message, 'error');
                } finally {
                    generateBtn.disabled = false;
                }
            }

            addTextToCanvas(canvasWithLogo, text, originalQRSize, textSize = 16, textColor = '#000000') {
                if (!text || text.trim() === '') {
                    return canvasWithLogo;
                }
                
                // Create a new canvas with space for text if needed
                const newCanvas = document.createElement('canvas');
                const textPadding = 20;
                const minTextSpace = textSize + 40;
                
                // Calculate required canvas dimensions
                let requiredHeight = canvasWithLogo.height;
                if (canvasWithLogo.qrArea) {
                    // Check if we have enough space below QR area
                    const spaceAfterQR = canvasWithLogo.height - (canvasWithLogo.qrArea.y + canvasWithLogo.qrArea.height);
                    if (spaceAfterQR < minTextSpace) {
                        requiredHeight = canvasWithLogo.qrArea.y + canvasWithLogo.qrArea.height + minTextSpace + textPadding;
                    }
                }
                
                // Set canvas dimensions (expand if needed for text)
                newCanvas.width = canvasWithLogo.width;
                newCanvas.height = Math.max(canvasWithLogo.height, requiredHeight);
                
                const ctx = newCanvas.getContext('2d');
                
                // Copy original canvas content
                ctx.drawImage(canvasWithLogo, 0, 0);
                
                // Fill any new space with white background
                if (newCanvas.height > canvasWithLogo.height) {
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, canvasWithLogo.height, newCanvas.width, newCanvas.height - canvasWithLogo.height);
                }
                
                // Calculate text position
                let textCenterX, textY;
                
                if (canvasWithLogo.qrArea) {
                    // Use QR area positioning (works for all cases: no logo, center logo, external logo)
                    textCenterX = canvasWithLogo.qrArea.x + (canvasWithLogo.qrArea.width / 2);
                    textY = canvasWithLogo.qrArea.y + canvasWithLogo.qrArea.height + textPadding;
                } else {
                    // Fallback: assume QR is centered in original canvas area
                    console.warn('qrArea not set, using fallback positioning');
                    textCenterX = newCanvas.width / 2;
                    // Position text below assumed QR code area
                    textY = Math.max(canvasWithLogo.height, newCanvas.height * 0.7) + textPadding;
                }
                
                // Draw text with customizable size and strong visibility
                ctx.fillStyle = textColor;
                ctx.font = `bold ${textSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                
                // Strong white outline for visibility
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.lineWidth = Math.max(3, textSize / 6);
                
                // Text wrapping for better layout
                const maxWidth = Math.min(newCanvas.width - 40, canvasWithLogo.qrArea ? canvasWithLogo.qrArea.width * 1.2 : newCanvas.width - 40);
                const lines = this.wrapText(ctx, text, maxWidth);
                
                // Draw each line of text
                lines.forEach((line, index) => {
                    const lineY = textY + (index * (textSize + 4));
                    if (lineY + textSize < newCanvas.height - 5) {
                        ctx.strokeText(line, textCenterX, lineY);
                        ctx.fillText(line, textCenterX, lineY);
                    }
                });
                
                // Copy qrArea and logoArea to new canvas
                if (canvasWithLogo.qrArea) newCanvas.qrArea = canvasWithLogo.qrArea;
                if (canvasWithLogo.logoArea) newCanvas.logoArea = canvasWithLogo.logoArea;
                if (canvasWithLogo.hasWhiteBackground) newCanvas.hasWhiteBackground = true;
                
                return newCanvas;
            }
            
            // Helper function for text wrapping
            wrapText(ctx, text, maxWidth) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = words[0] || '';
                
                for (let i = 1; i < words.length; i++) {
                    const testLine = currentLine + ' ' + words[i];
                    const metrics = ctx.measureText(testLine);
                    if (metrics.width > maxWidth && currentLine.length > 0) {
                        lines.push(currentLine);
                        currentLine = words[i];
                    } else {
                        currentLine = testLine;
                    }
                }
                
                if (currentLine.length > 0) {
                    lines.push(currentLine);
                }
                
                return lines.length > 0 ? lines : [text];
            }

            async applyQRCustomizations(canvas, qrStyle, roundness, logoSize, logoPosition, logoBackground, qrTransparency) {
                const originalQRSize = canvas.width;
                let finalCanvas;
                
                // Handle logo positioning - create larger canvas if logo is outside QR
                if (this.logoImage && logoPosition !== 'center') {
                    finalCanvas = await this.createCanvasWithExternalLogo(canvas, logoSize, logoPosition, logoBackground);
                } else {
                    // Create a canvas with proper text space allocation even without logo
                    const textSizeElement = document.getElementById('textSize');
                    const actualTextSize = textSizeElement ? parseInt(textSizeElement.value) : 16;
                    const textSpace = actualTextSize + 60; // Dynamic space based on text size + padding
                    const padding = 20;
                    
                    // Create canvas with space for text
                    finalCanvas = document.createElement('canvas');
                    finalCanvas.width = canvas.width + (padding * 2);
                    finalCanvas.height = canvas.height + textSpace + (padding * 2);
                    
                    const ctx = finalCanvas.getContext('2d');
                    
                    // Fill white background
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
                    
                    // Center the QR code horizontally and position at top with padding
                    const qrX = (finalCanvas.width - canvas.width) / 2;
                    const qrY = padding;
                    
                    // Draw QR code
                    ctx.drawImage(canvas, qrX, qrY);
                    
                    // Set QR area for text positioning (CRITICAL for no-logo case!)
                    finalCanvas.qrArea = { x: qrX, y: qrY, width: canvas.width, height: canvas.height };
                    
                    // Apply center logo if exists
                    if (this.logoImage && logoPosition === 'center') {
                        await this.applyCenterLogo(finalCanvas, logoSize, logoBackground);
                    }
                }
                
                // Apply rounded corners to QR part only (not the entire canvas with external logos)
                if (qrStyle === 'rounded') {
                    this.applyRoundedCornersToQROnly(finalCanvas, roundness, logoPosition, originalQRSize);
                }
                
                // Apply transparency
                if (qrTransparency === 'transparent') {
                    this.makeBackgroundTransparent(finalCanvas, logoPosition, originalQRSize);
                }
                
                return finalCanvas;
            }

            applyRoundedCorners(canvas, roundnessPercent) {
                const ctx = canvas.getContext('2d');
                const radius = (canvas.width * roundnessPercent) / 200; // Convert percentage to radius
                
                // Create a new canvas for the rounded version
                const roundedCanvas = document.createElement('canvas');
                roundedCanvas.width = canvas.width;
                roundedCanvas.height = canvas.height;
                const roundedCtx = roundedCanvas.getContext('2d');
                
                // Create rounded rectangle mask
                roundedCtx.beginPath();
                roundedCtx.roundRect(0, 0, canvas.width, canvas.height, radius);
                roundedCtx.clip();
                
                // Draw the original QR code
                roundedCtx.drawImage(canvas, 0, 0);
                
                // Copy the rounded version back to the original canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(roundedCanvas, 0, 0);
            }

            async createCanvasWithExternalLogo(qrCanvas, logoSizePercent, logoPosition, logoBackground) {
                if (!this.logoImage) return qrCanvas;
                
                const qrSize = qrCanvas.width;
                
                // Constrain logo size to prevent excessive scaling
                const maxLogoPercent = 40;
                const constrainedLogoPercent = Math.min(logoSizePercent, maxLogoPercent);
                const logoSize = (qrSize * constrainedLogoPercent) / 100;
                
                // DYNAMIC CANVAS APPROACH - Calculate exact size needed for all content
                const padding = 20;
                
                // Get text size from DOM element (make it dynamic)
                const textSizeElement = document.getElementById('textSize');
                const actualTextSize = textSizeElement ? parseInt(textSizeElement.value) : 16;
                const textSpace = actualTextSize + 60; // Dynamic space based on text size + padding
                
                let canvasWidth, canvasHeight;
                let qrX, qrY;
                let logoX, logoY;
                
                switch (logoPosition) {
                    case 'top':
                        // DYNAMIC CANVAS - Calculate exact size needed
                        canvasWidth = Math.max(qrSize, logoSize) + (padding * 2);
                        canvasHeight = logoSize + qrSize + textSpace + (padding * 3);
                        
                        // Position logo at top center
                        logoX = (canvasWidth - logoSize) / 2;
                        logoY = padding;
                        
                        // Position QR below logo with proper spacing
                        qrX = (canvasWidth - qrSize) / 2;
                        qrY = logoY + logoSize + padding;
                        
                        break;
                    case 'bottom':
                        // DYNAMIC CANVAS - Calculate exact size needed
                        canvasWidth = Math.max(qrSize, logoSize) + (padding * 2);
                        canvasHeight = qrSize + logoSize + textSpace + (padding * 3);
                        
                        // Position QR at top center
                        qrX = (canvasWidth - qrSize) / 2;
                        qrY = padding;
                        
                        // Position logo below QR with proper spacing
                        logoX = (canvasWidth - logoSize) / 2;
                        logoY = qrY + qrSize + padding;
                        break;
                    case 'left':
                        // DYNAMIC CANVAS - Calculate exact size needed
                        canvasWidth = logoSize + qrSize + (padding * 3);
                        canvasHeight = Math.max(qrSize, logoSize) + textSpace + (padding * 2);
                        
                        // Position logo at left center
                        logoX = padding;
                        logoY = (canvasHeight - textSpace - logoSize) / 2;
                        
                        // Position QR to the right of logo
                        qrX = logoX + logoSize + padding;
                        qrY = (canvasHeight - textSpace - qrSize) / 2;
                        break;
                    case 'right':
                        // DYNAMIC CANVAS - Calculate exact size needed
                        canvasWidth = qrSize + logoSize + (padding * 3);
                        canvasHeight = Math.max(qrSize, logoSize) + textSpace + (padding * 2);
                        
                        // Position QR at left center
                        qrX = padding;
                        qrY = (canvasHeight - textSpace - qrSize) / 2;
                        
                        // Position logo to the right of QR
                        logoX = qrX + qrSize + padding;
                        logoY = (canvasHeight - textSpace - logoSize) / 2;
                        break;
                    default:
                        return qrCanvas;
                }
                
                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = canvasWidth;
                finalCanvas.height = canvasHeight;
                const ctx = finalCanvas.getContext('2d');
                
                // Create a white background for visibility, then make specific areas transparent later
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvasWidth, canvasHeight);
                
                // Draw QR code at actual size
                ctx.drawImage(qrCanvas, qrX, qrY, qrSize, qrSize);
                
                // Draw logo with optional background at actual size
                if (logoBackground) {
                    const bgPadding = logoSize * 0.12;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.roundRect(logoX - bgPadding, logoY - bgPadding, 
                                logoSize + bgPadding * 2, logoSize + bgPadding * 2, bgPadding / 2);
                    ctx.fill();
                }
                
                // Draw logo at actual size
                ctx.drawImage(this.logoImage, logoX, logoY, logoSize, logoSize);
                
                // Store positioning info with actual sizes
                finalCanvas.qrArea = { x: qrX, y: qrY, width: qrSize, height: qrSize };
                finalCanvas.logoArea = { x: logoX, y: logoY, width: logoSize, height: logoSize };
                finalCanvas.hasWhiteBackground = true; // Flag for transparency processing
                
                return finalCanvas;
            }

            async applyCenterLogo(canvas, logoSizePercent, withBackground) {
                if (!this.logoImage) return;
                
                const ctx = canvas.getContext('2d');
                
                // Constrain logo size to prevent it from exceeding canvas boundaries
                // Maximum logo size should be 40% of canvas to maintain QR code readability
                const maxLogoPercent = 40;
                const constrainedLogoPercent = Math.min(logoSizePercent, maxLogoPercent);
                
                const logoSize = (canvas.width * constrainedLogoPercent) / 100;
                
                // Ensure logo doesn't exceed canvas bounds with some padding
                const maxLogoSize = Math.min(canvas.width * 0.4, canvas.height * 0.4);
                const finalLogoSize = Math.min(logoSize, maxLogoSize);
                
                const x = (canvas.width - finalLogoSize) / 2;
                const y = (canvas.height - finalLogoSize) / 2;
                
                // Add white background if requested
                if (withBackground) {
                    const padding = finalLogoSize * 0.1;
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.roundRect(x - padding, y - padding, finalLogoSize + padding * 2, finalLogoSize + padding * 2, padding);
                    ctx.fill();
                }
                
                // Draw the logo with proper sizing
                ctx.drawImage(this.logoImage, x, y, finalLogoSize, finalLogoSize);
            }

            applyRoundedCornersToQROnly(canvas, roundnessPercent, logoPosition, originalQRSize) {
                const ctx = canvas.getContext('2d');
                
                // Much more conservative radius to preserve QR structure
                const maxRadius = originalQRSize / 12; // Limit to 1/12th of QR size
                const radius = Math.min((originalQRSize * roundnessPercent) / 300, maxRadius);
                
                // Get QR area from canvas if available, or use defaults
                let qrArea;
                if (canvas.qrArea) {
                    qrArea = canvas.qrArea;
                } else {
                    // Default to entire canvas for center logos
                    qrArea = { x: 0, y: 0, width: originalQRSize, height: originalQRSize };
                }
                
                // Create a temporary canvas to work with just the QR area
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = qrArea.width;
                tempCanvas.height = qrArea.height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Copy QR area to temp canvas
                tempCtx.drawImage(canvas, qrArea.x, qrArea.y, qrArea.width, qrArea.height, 0, 0, qrArea.width, qrArea.height);
                
                // Create rounded mask - very conservative
                const maskCanvas = document.createElement('canvas');
                maskCanvas.width = qrArea.width;
                maskCanvas.height = qrArea.height;
                const maskCtx = maskCanvas.getContext('2d');
                
                // Create a very gentle rounded rectangle
                maskCtx.beginPath();
                maskCtx.roundRect(0, 0, qrArea.width, qrArea.height, radius);
                maskCtx.fill();
                
                // Apply mask to temp canvas
                tempCtx.globalCompositeOperation = 'destination-in';
                tempCtx.drawImage(maskCanvas, 0, 0);
                
                // Clear the QR area on main canvas and draw rounded version
                ctx.clearRect(qrArea.x, qrArea.y, qrArea.width, qrArea.height);
                ctx.drawImage(tempCanvas, qrArea.x, qrArea.y);
            }

            makeBackgroundTransparent(canvas, logoPosition, originalQRSize) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                // Get QR area and logo area if they exist
                const qrArea = canvas.qrArea || { x: 0, y: 0, width: canvas.width, height: canvas.height };
                const logoArea = canvas.logoArea || { x: 0, y: 0, width: 0, height: 0 };
                
                // Make white background transparent while preserving content
                for (let i = 0; i < data.length; i += 4) {
                    const pixelIndex = i / 4;
                    const x = pixelIndex % canvas.width;
                    const y = Math.floor(pixelIndex / canvas.width);
                    
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const alpha = data[i + 3];
                    
                    if (alpha === 0) continue;
                    
                    // Calculate brightness (0-255)
                    const brightness = (r * 0.299 + g * 0.587 + b * 0.114);
                    
                    // Check areas
                    const inQRArea = (x >= qrArea.x && x < qrArea.x + qrArea.width && 
                                     y >= qrArea.y && y < qrArea.y + qrArea.height);
                    const inLogoArea = (x >= logoArea.x && x < logoArea.x + logoArea.width && 
                                       y >= logoArea.y && y < logoArea.y + logoArea.height);
                    
                    // Keep content areas visible, make white background transparent
                    if (brightness > 240 && !inQRArea && !inLogoArea) {
                        // Pure white background - make transparent
                        data[i + 3] = 0;
                    } else if (brightness < 50) {
                        // Very dark pixels (QR modules, text) - keep black
                        data[i] = 0;
                        data[i + 1] = 0;
                        data[i + 2] = 0;
                        data[i + 3] = 255;
                    } else if (inQRArea || inLogoArea) {
                        // Content areas - keep visible
                        data[i + 3] = 255;
                    } else if (brightness > 200) {
                        // Light background outside content - make transparent
                        data[i + 3] = 0;
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            }

            drawTransparencyBackground(ctx, width, height) {
                // Draw checkerboard pattern to show transparency
                const squareSize = 10;
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, width, height);
                
                ctx.fillStyle = '#e0e0e0';
                for (let x = 0; x < width; x += squareSize) {
                    for (let y = 0; y < height; y += squareSize) {
                        if ((Math.floor(x / squareSize) + Math.floor(y / squareSize)) % 2 === 1) {
                            ctx.fillRect(x, y, squareSize, squareSize);
                        }
                    }
                }
            }

            async downloadZip() {
                if (this.generatedQRs.length === 0) {
                    this.showStatus('No QR codes to download!', 'error');
                    return;
                }

                this.showStatus('Creating ZIP file with all QR codes...');

                try {
                    // Check if JSZip is available
                    if (typeof JSZip !== 'undefined') {
                        // Use real JSZip library
                        const zip = new JSZip();
                        
                        // Add all QR codes to the ZIP
                        this.generatedQRs.forEach(qr => {
                            zip.file(qr.filename, qr.blob);
                        });
                        
                        // Generate ZIP file
                        const zipBlob = await zip.generateAsync({ 
                            type: 'blob',
                            compression: "DEFLATE",
                            compressionOptions: { level: 6 }
                        });
                        
                        // Download the ZIP file
                        const timestamp = new Date().toISOString().slice(0, 10);
                        this.downloadFile(zipBlob, `qr_codes_${timestamp}.zip`);
                        
                        this.showStatus(`ZIP file downloaded with ${this.generatedQRs.length} QR codes!`, 'success');
                        
                    } else {
                        // Fallback: Download files individually
                        this.showStatus('JSZip not available. Downloading files individually...');
                        
                        for (let i = 0; i < this.generatedQRs.length; i++) {
                            const qr = this.generatedQRs[i];
                            this.downloadFile(qr.blob, qr.filename);
                            
                            // Small delay between downloads
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                        
                        this.showStatus(`Downloaded ${this.generatedQRs.length} QR codes individually!`, 'success');
                    }

                } catch (error) {
                    console.error('Download failed:', error);
                    this.showStatus('Failed to create ZIP: ' + error.message, 'error');
                    
                    // Fallback to individual downloads
                    try {
                        this.showStatus('Falling back to individual downloads...');
                        for (let i = 0; i < this.generatedQRs.length; i++) {
                            const qr = this.generatedQRs[i];
                            this.downloadFile(qr.blob, qr.filename);
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                        this.showStatus(`Downloaded ${this.generatedQRs.length} QR codes individually!`, 'success');
                    } catch (fallbackError) {
                        this.showStatus('All download methods failed: ' + fallbackError.message, 'error');
                    }
                }
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, starting Offline QR Generator...');
            window.qrGenerator = new OfflineQRGenerator();
        });
    </script>

</body>
</html>